<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WalkSafe - Pavement Analyzer</title>

    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- PWA Theme Color -->
    <meta name="theme-color" content="#ffffff">

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #global-map {
            height: 300px;
            z-index: 0;
        }
        #submission-map {
            height: 200px;
            width: 100%;
            border-radius: 0.5rem;
            margin-top: 10px;
            z-index: 0;
        }
        /* manual privacy box style */
        .privacy-box {
            border: 2px solid black;
            background-color: rgba(0, 0, 0, 0.75);
        }
    </style>
</head>
<body class="h-full antialiased text-gray-900">
<div class="flex flex-col min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-md relative z-10">
        <div class="max-w-4xl mx-auto px-4 py-4">
            <h1 class="text-2xl font-bold text-blue-600">üåç WalkSafe</h1>
            <p class="text-gray-600">Report pavement accessibility issues with AI</p>
        </div>
    </header>

    <!-- Main -->
    <main class="flex-grow max-w-4xl mx-auto p-4 w-full">
        <div class="space-y-6">
            <!-- 1. Image Upload -->
            <div class="bg-white p-5 rounded-lg shadow">
                <h2 class="text-lg font-semibold mb-3">1. Capture Evidence</h2>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- Camera -->
                    <label for="camera-input"
                           class="cursor-pointer block w-full px-5 py-4 text-center bg-blue-600 text-white rounded-lg font-semibold shadow-sm hover:bg-blue-700 transition-colors flex flex-col items-center justify-center">
                        <span class="text-2xl mb-1">üì∑</span>
                        <span>Take Photo</span>
                    </label>
                    <input type="file" id="camera-input" class="hidden" accept="image/*" capture="environment">

                    <!-- Gallery -->
                    <label for="gallery-input"
                           class="cursor-pointer block w-full px-5 py-4 text-center bg-white border-2 border-gray-200 text-gray-700 rounded-lg font-semibold shadow-sm hover:bg-gray-50 transition-colors flex flex-col items-center justify-center">
                        <span class="text-2xl mb-1">üñºÔ∏è</span>
                        <span>Upload from Gallery</span>
                    </label>
                    <input type="file" id="gallery-input" class="hidden" accept="image/*">
                </div>

                <!-- Image preview + overlay -->
                <div id="image-preview-container" class="hidden mt-4 relative">
                    <div id="preview-wrapper" class="relative w-full max-w-md mx-auto">
                        <img id="image-preview" src="" alt="Image preview"
                             class="w-full rounded-lg shadow-inner select-none pointer-events-none"/>
                        <!-- overlay where user draws privacy boxes -->
                        <div id="privacy-overlay"
                             class="absolute inset-0 pointer-events-none"></div>
                    </div>

                    <!-- Remove image button -->
                    <button id="remove-image-btn"
                            class="absolute top-2 right-2 bg-red-500 text-white rounded-full p-2 shadow hover:bg-red-600"
                            title="Remove Image">
                        ‚úï
                    </button>

                    <!-- Privacy status -->
                    <p id="privacy-badge"
                       class="hidden text-center text-xs text-green-600 font-bold mt-2">
                        üõ°Ô∏è Faces redacted. Add boxes to hide license plates or other details.
                    </p>
                </div>
            </div>

            <!-- 2. AI Analysis & Location -->
            <div id="analysis-section" class="bg-white p-5 rounded-lg shadow hidden">
                <h2 class="text-lg font-semibold mb-3">2. AI Analysis &amp; Location</h2>

                <!-- Analyze button -->
                <button id="analyze-button"
                        class="w-full px-5 py-3 bg-green-600 text-white rounded-lg font-semibold shadow-sm hover:bg-green-700 transition-colors">
                    ‚ú® Analyze Pavement with AI
                </button>

                <!-- Loading indicator -->
                <div id="loading-container" class="hidden flex flex-col items-center justify-center my-4">
                    <div class="loader"></div>
                    <p class="mt-2 text-gray-600">Scanning for issues &amp; hiding faces...</p>
                </div>

                <!-- Results + form -->
                <div id="results-form" class="hidden mt-4 space-y-4">
                    <!-- AI notes -->
                    <div class="bg-blue-50 border border-blue-100 p-4 rounded-lg">
                        <h3 class="font-semibold text-sm text-blue-800">ü§ñ AI Analysis:</h3>
                        <p id="ai-notes" class="text-sm text-blue-900 mt-1"></p>
                    </div>

                    <div>
                        <label for="issue-type" class="block text-sm font-medium text-gray-700">Identified Issue</label>
                        <input type="text" id="issue-type"
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50">
                    </div>

                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="estimated-length" class="block text-sm font-medium text-gray-700">Length
                                (m)</label>
                            <input type="text" id="estimated-length"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="estimated-breadth" class="block text-sm font-medium text-gray-700">Breadth
                                (m)</label>
                            <input type="text" id="estimated-breadth"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                        </div>
                    </div>

                    <!-- Location -->
                    <div class="border-t pt-4 mt-4">
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium text-gray-700">üìç Incident Location</label>
                            <button type="button" id="get-location-btn"
                                    class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200">
                                Get Device Location
                            </button>
                        </div>

                        <div class="grid grid-cols-2 gap-4 mb-2">
                            <div>
                                <input type="text" id="latitude" placeholder="Latitude"
                                       class="block w-full rounded-md border-gray-300 shadow-sm text-sm" readonly>
                            </div>
                            <div>
                                <input type="text" id="longitude" placeholder="Longitude"
                                       class="block w-full rounded-md border-gray-300 shadow-sm text-sm" readonly>
                            </div>
                        </div>

                        <div id="submission-map"></div>
                        <p class="text-xs text-gray-500 mt-1 text-center">
                            Drag the blue pin to pinpoint the exact location.
                        </p>
                    </div>

                    <!-- Timestamp -->
                    <div>
                        <label for="image-timestamp"
                               class="block text-sm font-medium text-gray-700">Image Timestamp</label>
                        <input type="text" id="image-timestamp"
                               placeholder="e.g. 2023-10-27 14:30"
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                    </div>

                    <!-- AI confidence -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700">AI Confidence Score</label>
                        <div id="confidence-score" class="mt-1 text-lg font-bold text-blue-600"></div>
                    </div>

                    <!-- Privacy tools -->
                    <div class="border-t pt-4 mt-4">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2">üîí Manual Privacy Controls</h3>
                        <p class="text-xs text-gray-500 mb-2">
                            Faces are hidden automatically. To hide license plates or other details, draw one or more
                            black boxes over the image.
                        </p>
                        <div class="flex flex-wrap gap-2">
                            <button id="add-privacy-box-btn"
                                    class="px-3 py-1 text-xs bg-gray-100 rounded hover:bg-gray-200">
                                ‚ûï Add privacy box (click & drag)
                            </button>
                            <button id="clear-privacy-boxes-btn"
                                    class="px-3 py-1 text-xs bg-gray-100 rounded hover:bg-gray-200">
                                üßπ Clear boxes
                            </button>
                            <button id="apply-manual-privacy-btn"
                                    class="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700">
                                ‚úÖ Apply manual redaction
                            </button>
                        </div>
                    </div>

                    <!-- Submit -->
                    <button id="submit-button"
                            class="w-full px-5 py-3 bg-blue-600 text-white rounded-lg font-semibold shadow-sm hover:bg-blue-700 transition-colors">
                        Confirm &amp; Submit Report
                    </button>

                    <p id="submit-status" class="text-center text-green-600 font-semibold hidden"></p>
                </div>
            </div>

            <!-- 3. Community Map -->
            <div class="bg-white p-5 rounded-lg shadow">
                <h2 class="text-lg font-semibold mb-3">3. Community Map</h2>
                <p class="text-sm text-gray-600 mb-2">Issues reported by the community.</p>
                <div id="global-map" class="border border-gray-200 rounded-lg"></div>
            </div>

            <!-- 4. Feed -->
            <div class="bg-white p-5 rounded-lg shadow">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-semibold">4. Live Report Feed</h2>
                    <button id="download-csv-btn"
                            class="px-3 py-1 text-sm bg-blue-500 text-white rounded-lg shadow-sm hover:bg-blue-600 transition-colors">
                        Download CSV
                    </button>
                </div>
                <p class="text-sm text-gray-600 mb-4">
                    User ID: <span id="user-id" class="font-mono text-xs">loading...</span>
                </p>
                <div id="reports-list" class="space-y-3 max-h-96 overflow-y-auto">
                    <p id="reports-placeholder" class="text-gray-500">
                        No reports submitted yet. Sign in to load...
                    </p>
                </div>
            </div>
        </div>
    </main>
</div>

<!-- Firebase + App Logic -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        signInAnonymously,
        signInWithCustomToken,
        onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        addDoc,
        collection,
        query,
        onSnapshot
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- GLOBALS ---
    let db;
    let auth;
    let currentUserId = null;
    let currentImageBase64 = null;
    let aiAnalysisResult = null;
    let allReports = [];
    let globalMap;
    let submissionMap;
    let submissionMarker;
    let mapMarkers = [];

    // manual privacy drawing
    let manualBoxesNorm = []; // [{xmin,xmax,ymin,ymax} in 0-1]
    let isDrawingBox = false;
    let currentDrawBoxEl = null;
    let drawStart = null;

    // --- FIREBASE CONFIG ---
  const firebaseConfig = {
  apiKey: "AIzaSyD6xtueIU0RMA7716PuNmbCPpMQE5JiVF4",
  authDomain: "information-hiding-walksafe.firebaseapp.com",
  projectId: "information-hiding-walksafe",
  storageBucket: "information-hiding-walksafe.firebasestorage.app",
  messagingSenderId: "408626549768",
  appId: "1:408626549768:web:9a45703b7023f57d6b6dbd",
  measurementId: "G-1PJSW6599H"
};

    const effectiveConfig =
        (typeof __firebase_config !== "undefined")
            ? JSON.parse(__firebase_config)
            : firebaseConfig;

    const appId = typeof __app_id !== "undefined" ? __app_id : "walksafe-prototype";

    // --- GROQ VISION CONFIG ---
    const GROQ_API_KEY = "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"; 
    const GROQ_BASE_URL = "https://api.groq.com/openai/v1/chat/completions";
    const GROQ_VISION_MODEL = "meta-llama/llama-4-scout-17b-16e-instruct";

    // --- DOM REFS ---
    const cameraInput = document.getElementById("camera-input");
    const galleryInput = document.getElementById("gallery-input");
    const imagePreview = document.getElementById("image-preview");
    const imagePreviewContainer = document.getElementById("image-preview-container");
    const removeImageBtn = document.getElementById("remove-image-btn");
    const analysisSection = document.getElementById("analysis-section");
    const analyzeButton = document.getElementById("analyze-button");
    const loadingContainer = document.getElementById("loading-container");
    const resultsForm = document.getElementById("results-form");
    const aiNotes = document.getElementById("ai-notes");
    const issueTypeInput = document.getElementById("issue-type");
    const estimatedLengthInput = document.getElementById("estimated-length");
    const estimatedBreadthInput = document.getElementById("estimated-breadth");
    const latitudeInput = document.getElementById("latitude");
    const longitudeInput = document.getElementById("longitude");
    const imageTimestampInput = document.getElementById("image-timestamp");
    const confidenceScoreDisplay = document.getElementById("confidence-score");
    const submitButton = document.getElementById("submit-button");
    const submitStatus = document.getElementById("submit-status");
    const reportsList = document.getElementById("reports-list");
    const reportsPlaceholder = document.getElementById("reports-placeholder");
    const userIdDisplay = document.getElementById("user-id");
    const privacyBadge = document.getElementById("privacy-badge");
    const previewWrapper = document.getElementById("preview-wrapper");
    const privacyOverlay = document.getElementById("privacy-overlay");
    const addPrivacyBoxBtn = document.getElementById("add-privacy-box-btn");
    const clearPrivacyBoxesBtn = document.getElementById("clear-privacy-boxes-btn");
    const applyManualPrivacyBtn = document.getElementById("apply-manual-privacy-btn");
    const downloadCsvBtn = document.getElementById("download-csv-btn");

    // --- INIT ---
    function initApp() {
        try {
            if (!effectiveConfig.apiKey) {
                console.warn("Firebase config missing apiKey ‚Äì Firestore features may not work.");
            }
            const app = initializeApp(effectiveConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            initGlobalMap();
            initSubmissionMap();

            window.getUserLocation(false);

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUserId = user.uid;
                    userIdDisplay.textContent = currentUserId;
                    listenForReports();
                } else {
                    currentUserId = null;
                    userIdDisplay.textContent = "Not signed in";
                }
            });
            authenticateUser();
        } catch (e) {
            console.error("Init Error:", e);
            alert("App Init Error: " + e.message);
        }
    }

    async function authenticateUser() {
        try {
            const authToken =
                typeof __initial_auth_token !== "undefined" ? __initial_auth_token : null;
            if (authToken) await signInWithCustomToken(auth, authToken);
            else await signInAnonymously(auth);
        } catch (error) {
            console.error("Auth failed:", error);
            userIdDisplay.textContent = "Auth Error";
        }
    }

    // --- MAPS ---
    function initGlobalMap() {
        globalMap = L.map("global-map").setView([20, 0], 2);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "¬© OpenStreetMap"
        }).addTo(globalMap);
    }

    function initSubmissionMap() {
        submissionMap = L.map("submission-map").setView([0, 0], 2);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19
        }).addTo(submissionMap);

        submissionMap.on("click", (e) => {
            updateSubmissionLocation(e.latlng.lat, e.latlng.lng);
        });
    }

    // --- GEOLOCATION ---
    window.getUserLocation = (isManual = false) => {
        const btn = document.getElementById("get-location-btn");

        if (!navigator.geolocation) {
            if (isManual) alert("Geolocation is not supported by this browser.");
            return;
        }

        if (isManual && btn) {
            btn.textContent = "Locating...";
            btn.disabled = true;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;

                updateSubmissionLocation(lat, lng);

                if (submissionMap) {
                    submissionMap.setView([lat, lng], 15);
                    submissionMap.invalidateSize();
                }

                if (isManual && btn) {
                    btn.textContent = "Get Device Location";
                    btn.disabled = false;
                }
            },
            (error) => {
                console.warn("Geolocation error:", error);

                if (isManual) {
                    let msg = "Error getting location.";
                    if (error.code === error.PERMISSION_DENIED)
                        msg = "Location permission denied.";
                    else if (error.code === error.TIMEOUT)
                        msg = "Location request timed out.";
                    else if (error.code === error.POSITION_UNAVAILABLE)
                        msg = "Location unavailable.";
                    alert(msg);

                    if (btn) {
                        btn.textContent = "Get Device Location";
                        btn.disabled = false;
                    }
                }
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    };

    function updateSubmissionLocation(lat, lng) {
        latitudeInput.value = lat.toFixed(6);
        longitudeInput.value = lng.toFixed(6);

        if (submissionMarker) {
            submissionMarker.setLatLng([lat, lng]);
        } else {
            submissionMarker = L.marker([lat, lng], { draggable: true }).addTo(submissionMap);
            submissionMarker.on("dragend", (event) => {
                const position = event.target.getLatLng();
                latitudeInput.value = position.lat.toFixed(6);
                longitudeInput.value = position.lng.toFixed(6);
                submissionMap.panTo(position);
            });
        }
    }

    // --- IMAGE HANDLING ---
    function resetManualBoxes() {
        manualBoxesNorm = [];
        privacyOverlay.innerHTML = "";
        isDrawingBox = false;
        currentDrawBoxEl = null;
        drawStart = null;
    }

    function resetAnalysisUI() {
        analyzeButton.disabled = false;
        analyzeButton.classList.remove("hidden");
        loadingContainer.classList.add("hidden");
        resultsForm.classList.add("hidden");
        submitButton.disabled = false;
        submitStatus.classList.add("hidden");
        aiAnalysisResult = null;
        privacyBadge.classList.add("hidden");

        resetManualBoxes();
    }

    function resetAllImageUI() {
        resetAnalysisUI();
        imagePreviewContainer.classList.add("hidden");
        imagePreview.src = "";
        currentImageBase64 = null;
        cameraInput.value = "";
        galleryInput.value = "";
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        resetAllImageUI();

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const MAX_DIM = 1000;
                let w = img.width;
                let h = img.height;
                if (w > h) {
                    if (w > MAX_DIM) {
                        h *= MAX_DIM / w;
                        w = MAX_DIM;
                    }
                } else {
                    if (h > MAX_DIM) {
                        w *= MAX_DIM / h;
                        h = MAX_DIM;
                    }
                }

                const canvas = document.createElement("canvas");
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, w, h);

                const dataUrl = canvas.toDataURL("image/jpeg", 0.85);
                currentImageBase64 = dataUrl.split(",")[1];
                imagePreview.src = dataUrl;
                imagePreviewContainer.classList.remove("hidden");
                analysisSection.classList.remove("hidden");

                event.target.value = "";
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    cameraInput.addEventListener("change", handleImageUpload);
    galleryInput.addEventListener("change", handleImageUpload);
    removeImageBtn.addEventListener("click", resetAllImageUI);

    // --- REDACTION (accepts 0‚Äì1 or 0‚Äì1000 normalized boxes) ---
    async function redactSensitiveData(boundingBoxes) {
        if (!Array.isArray(boundingBoxes) || boundingBoxes.length === 0) {
            console.log("No boundingBoxes provided for redaction.");
            return null;
        }

        console.log("Redaction boxes:", boundingBoxes);

        const MARGIN_W = 0.15;
        const MARGIN_H = 0.25;

        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext("2d");

                ctx.drawImage(img, 0, 0);
                ctx.fillStyle = "black";

                boundingBoxes.forEach((rawBox, idx) => {
                    let { ymin, xmin, ymax, xmax } = rawBox || {};

                    ymin = Number(ymin);
                    xmin = Number(xmin);
                    ymax = Number(ymax);
                    xmax = Number(xmax);

                    if (
                        !Number.isFinite(ymin) ||
                        !Number.isFinite(xmin) ||
                        !Number.isFinite(ymax) ||
                        !Number.isFinite(xmax)
                    ) {
                        console.warn("Skipping invalid box:", rawBox);
                        return;
                    }

                    const maxAbs = Math.max(
                        Math.abs(ymin),
                        Math.abs(xmin),
                        Math.abs(ymax),
                        Math.abs(xmax)
                    );
                    const isFractionScale = maxAbs <= 1.05;

                    let top, left, bottom, right;
                    if (isFractionScale) {
                        top = ymin * img.height;
                        left = xmin * img.width;
                        bottom = ymax * img.height;
                        right = xmax * img.width;
                    } else {
                        top = (ymin / 1000) * img.height;
                        left = (xmin / 1000) * img.width;
                        bottom = (ymax / 1000) * img.height;
                        right = (xmax / 1000) * img.width;
                    }

                    let w = right - left;
                    let h = bottom - top;
                    if (w < 3 || h < 3) {
                        console.warn("Skipping tiny/negative box:", rawBox);
                        return;
                    }

                    let expandedLeft = left - w * MARGIN_W;
                    let expandedRight = right + w * MARGIN_W;
                    let expandedTop = top - h * MARGIN_H;
                    let expandedBottom = bottom + h * MARGIN_H;

                    expandedLeft = Math.max(0, Math.min(img.width, expandedLeft));
                    expandedRight = Math.max(0, Math.min(img.width, expandedRight));
                    expandedTop = Math.max(0, Math.min(img.height, expandedTop));
                    expandedBottom = Math.max(
                        0,
                        Math.min(img.height, expandedBottom)
                    );

                    const finalW = expandedRight - expandedLeft;
                    const finalH = expandedBottom - expandedTop;
                    if (finalW < 3 || finalH < 3) return;

                    console.log(`Applying redaction #${idx}`, {
                        left: expandedLeft,
                        top: expandedTop,
                        w: finalW,
                        h: finalH
                    });
                    ctx.fillRect(expandedLeft, expandedTop, finalW, finalH);
                });

                const redactedDataUrl = canvas.toDataURL("image/jpeg", 0.85);
                resolve(redactedDataUrl);
            };

            img.src = "data:image/jpeg;base64," + currentImageBase64;
        });
    }

    // --- GROQ ANALYSIS ---
    async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
        for (let i = 0; i < retries; i++) {
            try {
                const res = await fetch(url, options);
                if (res.ok) return res;
                if (res.status === 429 || res.status >= 500) {
                    await new Promise((r) => setTimeout(r, delay * Math.pow(2, i)));
                } else {
                    return res;
                }
            } catch (e) {
                await new Promise((r) => setTimeout(r, delay * Math.pow(2, i)));
            }
        }
        return fetch(url, options);
    }

    window.analyzeImage = async () => {
        if (!currentImageBase64) {
            alert("Please upload an image first.");
            return;
        }
        if (!GROQ_API_KEY) {
            alert("Missing Groq API key. Add it in the source before testing.");
            return;
        }

        analyzeButton.classList.add("hidden");
        loadingContainer.classList.remove("hidden");
        resultsForm.classList.add("hidden");
        submitStatus.classList.add("hidden");
        resetManualBoxes();

        setTimeout(() => {
            if (submissionMap) submissionMap.invalidateSize();
        }, 100);

        const systemPrompt = `
You are a pavement accessibility expert AND privacy assistant.

Return exactly ONE JSON object with the following fields:
- issueType: short description of the main pavement issue (string).
- estimatedLengthMeters: number (0 if unclear).
- estimatedBreadthMeters: number (0 if unclear).
- imageTimestamp: string timestamp if visible in the image, otherwise "null".
- confidenceScore: number from 0.0 to 1.0.
- analysisNotes: brief explanation (string).
- faceBoxes: array of bounding boxes ONLY for human faces.
  Each box is an object { "ymin": number, "xmin": number, "ymax": number, "xmax": number }
  with ALL coordinates NORMALIZED to the range [0,1] relative to image height/width.

IMPORTANT:
- Do NOT include license plates in faceBoxes.
- Do NOT mention GPS, plates, or other privacy-sensitive text, only return faceBoxes for human faces.
`.trim();

        const userPrompt = `
Analyze this pavement photo.

1) Describe any accessibility issues (e.g. cracks, obstacles, blocked ramps) and give rough length and breadth in meters.
2) If any timestamp is printed in the image (e.g. camera overlay), extract it as a string.
3) Detect ALL HUMAN FACES and return tight bounding boxes around the faces as "faceBoxes" (normalized 0-1).
`.trim();

        const payload = {
            model: GROQ_VISION_MODEL,
            response_format: { type: "json_object" },
            messages: [
                { role: "system", content: systemPrompt },
                {
                    role: "user",
                    content: [
                        { type: "text", text: userPrompt },
                        {
                            type: "image_url",
                            image_url: { url: "data:image/jpeg;base64," + currentImageBase64 }
                        }
                    ]
                }
            ]
        };

        try {
            const response = await fetchWithRetry(GROQ_BASE_URL, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: "Bearer " + GROQ_API_KEY
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`API Error: ${response.status} ‚Äì ${text}`);
            }

            const result = await response.json();
            const textContent = result.choices?.[0]?.message?.content;
            if (!textContent) throw new Error("Invalid API response format.");
            aiAnalysisResult = JSON.parse(textContent);

            // auto-redact faces if any
            if (aiAnalysisResult.faceBoxes && aiAnalysisResult.faceBoxes.length > 0) {
                const redactedUrl = await redactSensitiveData(aiAnalysisResult.faceBoxes);
                if (redactedUrl) {
                    currentImageBase64 = redactedUrl.split(",")[1];
                    imagePreview.src = redactedUrl;
                    privacyBadge.classList.remove("hidden");
                    privacyBadge.textContent =
                        `üõ°Ô∏è Faces redacted automatically (${aiAnalysisResult.faceBoxes.length} face(s)).` +
                        " Use manual boxes for plates.";
                }
            }

            displayAnalysisResults(aiAnalysisResult);
        } catch (error) {
            console.error("AI Error:", error);
            alert(`Analysis failed: ${error.message}`);
            analyzeButton.classList.remove("hidden");
        } finally {
            loadingContainer.classList.add("hidden");
        }
    };

    function displayAnalysisResults(data) {
        aiNotes.textContent = data.analysisNotes || "No notes.";
        issueTypeInput.value = data.issueType || "";
        estimatedLengthInput.value =
            data.estimatedLengthMeters != null ? data.estimatedLengthMeters : "";
        estimatedBreadthInput.value =
            data.estimatedBreadthMeters != null ? data.estimatedBreadthMeters : "";

        let timeVal = data.imageTimestamp;
        if (!timeVal || String(timeVal).toLowerCase() === "null") {
            timeVal = new Date().toLocaleString();
        }
        imageTimestampInput.value = timeVal;

        const conf = (data.confidenceScore || 0) * 100;
        confidenceScoreDisplay.textContent = `${conf.toFixed(1)}%`;

        resultsForm.classList.remove("hidden");
    }

    // --- MANUAL PRIVACY DRAWING (multiple boxes) ---
    addPrivacyBoxBtn.addEventListener("click", () => {
        if (!imagePreviewContainer.classList.contains("hidden")) {
            isDrawingBox = true;
            privacyOverlay.style.pointerEvents = "auto";
        }
    });

    clearPrivacyBoxesBtn.addEventListener("click", () => {
        resetManualBoxes();
    });

    privacyOverlay.addEventListener("mousedown", (e) => {
        if (!isDrawingBox) return;

        const rect = privacyOverlay.getBoundingClientRect();
        const startX = e.clientX - rect.left;
        const startY = e.clientY - rect.top;

        currentDrawBoxEl = document.createElement("div");
        currentDrawBoxEl.className =
            "privacy-box absolute";
        currentDrawBoxEl.style.left = `${startX}px`;
        currentDrawBoxEl.style.top = `${startY}px`;
        currentDrawBoxEl.style.width = "0px";
        currentDrawBoxEl.style.height = "0px";

        privacyOverlay.appendChild(currentDrawBoxEl);

        drawStart = { x: startX, y: startY };
    });

    window.addEventListener("mousemove", (e) => {
        if (!drawStart || !currentDrawBoxEl) return;

        const rect = privacyOverlay.getBoundingClientRect();
        let currX = e.clientX - rect.left;
        let currY = e.clientY - rect.top;

        currX = Math.max(0, Math.min(rect.width, currX));
        currY = Math.max(0, Math.min(rect.height, currY));

        const left = Math.min(drawStart.x, currX);
        const top = Math.min(drawStart.y, currY);
        const width = Math.abs(currX - drawStart.x);
        const height = Math.abs(currY - drawStart.y);

        currentDrawBoxEl.style.left = `${left}px`;
        currentDrawBoxEl.style.top = `${top}px`;
        currentDrawBoxEl.style.width = `${width}px`;
        currentDrawBoxEl.style.height = `${height}px`;
    });

    window.addEventListener("mouseup", () => {
        if (!drawStart || !currentDrawBoxEl) {
            drawStart = null;
            return;
        }

        const rect = privacyOverlay.getBoundingClientRect();
        const boxRect = currentDrawBoxEl.getBoundingClientRect();

        const left = boxRect.left - rect.left;
        const top = boxRect.top - rect.top;
        const width = boxRect.width;
        const height = boxRect.height;

        if (width < 5 || height < 5) {
            // too small, discard
            privacyOverlay.removeChild(currentDrawBoxEl);
        } else {
            // save as normalized 0‚Äì1 coords
            const xmin = left / rect.width;
            const ymin = top / rect.height;
            const xmax = (left + width) / rect.width;
            const ymax = (top + height) / rect.height;

            manualBoxesNorm.push({ xmin, ymin, xmax, ymax });
            console.log("Added manual box:", { xmin, ymin, xmax, ymax });
        }

        drawStart = null;
        currentDrawBoxEl = null;
        isDrawingBox = false;
        privacyOverlay.style.pointerEvents = "none";
    });

    applyManualPrivacyBtn.addEventListener("click", async () => {
        if (!currentImageBase64) {
            alert("No image loaded.");
            return;
        }
        if (!manualBoxesNorm.length) {
            alert("Draw at least one privacy box first.");
            return;
        }

        const redactedUrl = await redactSensitiveData(manualBoxesNorm);
        if (redactedUrl) {
            currentImageBase64 = redactedUrl.split(",")[1];
            imagePreview.src = redactedUrl;
            privacyBadge.classList.remove("hidden");
            privacyBadge.textContent = "üõ°Ô∏è Faces + manual privacy boxes applied.";
            resetManualBoxes();
        }
    });

    // --- SUBMIT REPORT ---
    window.submitReport = async () => {
        if (!currentUserId || !aiAnalysisResult) {
            alert("Authentication or AI analysis missing.");
            return;
        }
        submitButton.disabled = true;
        submitStatus.textContent = "Submitting...";
        submitStatus.classList.remove("hidden", "text-red-600");
        submitStatus.classList.add("text-yellow-600");

        const report = {
            userId: currentUserId,
            aiIssueType: aiAnalysisResult.issueType,
            aiLengthMeters: aiAnalysisResult.estimatedLengthMeters,
            aiBreadthMeters: aiAnalysisResult.estimatedBreadthMeters,
            aiConfidence: aiAnalysisResult.confidenceScore,
            aiNotes: aiAnalysisResult.analysisNotes,
            finalIssueType: issueTypeInput.value,
            finalLengthMeters: parseFloat(estimatedLengthInput.value) || 0,
            finalBreadthMeters: parseFloat(estimatedBreadthInput.value) || 0,
            finalLatitude: parseFloat(latitudeInput.value) || null,
            finalLongitude: parseFloat(longitudeInput.value) || null,
            finalImageTimestamp: imageTimestampInput.value,
            userCorrected: issueTypeInput.value !== aiAnalysisResult.issueType,
            createdAt: new Date()
        };

        try {
            const path = `/artifacts/${appId}/public/data/reports`;
            await addDoc(collection(db, path), report);
            submitStatus.textContent = "Submitted Successfully!";
            submitStatus.classList.replace("text-yellow-600", "text-green-600");

            setTimeout(() => {
                resultsForm.classList.add("hidden");
                analysisSection.classList.add("hidden");
                imagePreviewContainer.classList.add("hidden");
                currentImageBase64 = null;
            }, 1500);
        } catch (e) {
            submitStatus.textContent = "Error: " + e.message;
            submitStatus.classList.replace("text-yellow-600", "text-red-600");
            submitButton.disabled = false;
        }
    };

    // --- FEED & MAP ---
    function listenForReports() {
        if (!db) return;
        const q = query(collection(db, `/artifacts/${appId}/public/data/reports`));
        onSnapshot(q, (snapshot) => {
            if (snapshot.empty) {
                reportsList.innerHTML = "";
                reportsPlaceholder.classList.remove("hidden");
                return;
            }
            reportsPlaceholder.classList.add("hidden");
            const reports = [];
            snapshot.forEach((docSnap) => reports.push({ id: docSnap.id, data: docSnap.data() }));
            reports.sort(
                (a, b) => (b.data.createdAt?.seconds || 0) - (a.data.createdAt?.seconds || 0)
            );
            allReports = reports;
            renderReports(reports);
            updateGlobalMap(reports);
        });
    }

    function updateGlobalMap(reports) {
        if (!globalMap) return;
        mapMarkers.forEach((m) => m.remove());
        mapMarkers = [];
        const bounds = [];

        reports.forEach((r) => {
            const d = r.data;
            if (d.finalLatitude && d.finalLongitude) {
                const m = L.marker([d.finalLatitude, d.finalLongitude]).addTo(globalMap);
                m.bindPopup(
                    `<b>${d.finalIssueType}</b><br>${d.finalLengthMeters}m long<br><span style="font-size:0.8em">${new Date(
                        (d.createdAt?.seconds || 0) * 1000
                    ).toLocaleDateString()}</span>`
                );
                mapMarkers.push(m);
                bounds.push([d.finalLatitude, d.finalLongitude]);
            }
        });

        if (bounds.length > 0) globalMap.fitBounds(bounds, { padding: [50, 50] });
    }

    function renderReports(reports) {
        reportsList.innerHTML = "";
        reports.forEach((r) => {
            const d = r.data;
            const loc = d.finalLatitude
                ? `üìç ${d.finalLatitude.toFixed(4)}, ${d.finalLongitude.toFixed(4)}`
                : "";
            const el = document.createElement("div");
            el.className = "border border-gray-200 p-3 rounded-lg bg-gray-50 text-sm";
            el.innerHTML = `
                <div class="font-bold text-blue-700 flex justify-between">
                    <span>${d.finalIssueType}</span>
                    <span>${d.finalLengthMeters}m</span>
                </div>
                <div class="text-xs text-gray-500 mt-1">${loc}</div>
                <div class="text-xs text-gray-400 mt-1">
                    ${new Date((d.createdAt?.seconds || 0) * 1000).toLocaleString()}
                </div>`;
            reportsList.appendChild(el);
        });
    }

    // --- CSV DOWNLOAD ---
    downloadCsvBtn.addEventListener("click", () => {
        if (!allReports.length) {
            alert("No reports.");
            return;
        }
        const keys = [
            "userId",
            "finalIssueType",
            "finalLengthMeters",
            "finalLatitude",
            "finalLongitude",
            "finalImageTimestamp",
            "aiConfidence",
            "createdAt"
        ];
        let csv = keys.join(",") + "\n";
        allReports.forEach((r) => {
            const d = r.data;
            const row = keys.map((k) => {
                let val = d[k];
                if (k === "createdAt") {
                    val = new Date((val?.seconds || 0) * 1000).toISOString();
                }
                return `"${String(val || "").replace(/"/g, '""')}"`;
            });
            csv += row.join(",") + "\n";
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(new Blob([csv], { type: "text/csv" }));
        link.download = "walksafe_data.csv";
        link.click();
    });

    // --- PWA SW ---
    if ("serviceWorker" in navigator && window.location.protocol.startsWith("http")) {
        navigator.serviceWorker
            .register("/sw.js")
            .then((reg) => console.log("SW registered:", reg.scope))
            .catch((err) =>
                console.log("SW registration failed (expected in preview/blob envs):", err)
            );
    }

    // wire analyze & submit buttons
    analyzeButton.addEventListener("click", window.analyzeImage);
    submitButton.addEventListener("click", window.submitReport);

    // start
    initApp();
</script>
</body>
</html>
